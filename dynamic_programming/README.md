## Dynamic Programming 
[_Dynamic programming_](http://en.wikipedia.org/wiki/Dynamic_programming) is an algorithm technique which is usually based on: 
* recurrent formula
* one or more starting states

A sub-solution of the problem is constructed from previously found ones, which starts from the starting states.
DP solutions have a polynomial complexity where the brute-force or backtracking solutions usually have exponantial solutions.
DP computes the recurrence efficiently because it stores (memoized) the sub-probelms and use the results instead of recalculating them everytime.

#### Examples
These are the examples implemented in this project:
The resources used are the following 
[_TopCoder_](http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=dynProg) and [_The Algorithm Design Manual_](http://www. algorist.com/)

* [_Fibonacci number_](http://en.wikipedia.org/wiki/Fibonacci_number)
* [_Longest Increasing Sub Sequence_](http://en.wikipedia.org/wiki/Longest_increasing_subsequence)
* Min total coins to add to a sum
* [_Floyd–Warshall_](http://en.wikipedia.org/wiki/Floyd-Warshall_algorithm): Single source shortest path for in a graph with positive and negative weighed edges (not started)
* [_Bellman–Ford_](http://en.wikipedia.org/wiki/Bellman-Ford_algorithm): Single source shortest path for a graph with positive and negative weighted edges, but no negative cycles. (not started yet)
* [_Dijkstra Algorithm_](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm): Single source shortest path for a grpah with only positive edges.(hasn't started)
* [_String Matching_](http://en.wikipedia.org/wiki/String_searching_algorithm) 
* [_Partitioning Problem_](http://en.wikipedia.org/wiki/Partition_problem) (working on it)
